import * as React from "react";
import { Layer, Text, Rect, Transformer } from "react-konva";
import Konva from "konva";

export interface TextFragment {
  color: string;
  size: number;
  sizeOffset?: number;
  id?: string;
  displayText: string;
}

export interface TextLayer {
  top_x: number;
  top_y: number;
  bottom_x: number;
  bottom_y: number;
  rotation: number;
  align: string;
  fragments: Array<TextFragment>;
  border?: string;
  id?: string;
}

interface Props {
  id: string;
  text: TextLayer;
  selected?: boolean;
  updateTextLayer: (id: string, layer: TextLayer) => void;
}
class CanvasTextLayer extends React.Component<
  Props,
  {
    textPositions: Array<{ x: number; line: number }>;
    lineHeights: Array<number>;
  }
> {
  fragmentRefs = new Array<React.RefObject<Konva.Text>>();

  static initialState = () => ({
    textPositions: new Array<{ x: number; line: number }>(),
    lineHeights: new Array<number>(),
  });

  state = CanvasTextLayer.initialState();

  componentDidUpdate() {
    console.log(this.fragmentRefs);
    let next = 0;
    let nextLine = 0;
    let lineHeights = new Array<number>();
    let textPositions = this.fragmentRefs.map((fragment) => {
      const text = fragment.current;
      const position = {
        x: next,
        line: nextLine,
      };
      text.textArr.forEach((text) =>
        lineHeights.push(fragment.current.fontSize())
      );
      nextLine = nextLine + text.textArr.length;
      // next = text.textArr[text.textArr.length - 1].width;
      console.log(position);
      return position;
    });

    if (this.state.textPositions.length == textPositions.length) {
      if (
        this.state.textPositions.every((value, index) => {
          return (
            value.x == textPositions[index].x &&
            value.line == textPositions[index].line
          );
        })
      ) {
        return;
      }
    }

    this.setState((state) => ({
      ...state,
      lineHeights,
      textPositions,
    }));
  }

  componentDidMount() {
    console.log(this.fragmentRefs);
  }

  getTextY(fragment: TextFragment, index: number, defaultY: number) {
    if (this.state.textPositions.length <= index) {
      return defaultY;
    }
    let y = defaultY;
    for (let i = 0; i < this.state.textPositions[index].line; i++) {
      y += this.state.lineHeights[i];
    }
    return y;
  }

  render() {
    let { id, text, selected, updateTextLayer } = this.props;
    let ref = React.createRef<Konva.Rect>();
    let start = {} as any;
    this.fragmentRefs = new Array<React.RefObject<Konva.Text>>();
    let fragments = text.fragments.map((fragment, index) => {
      this.fragmentRefs.push(React.createRef<Konva.Text>());
      return (
        <Text
          key={id + "_" + index}
          x={text.top_x}
          y={this.getTextY(fragment, index, text.top_y)}
          width={text.bottom_x - text.top_x}
          height={text.bottom_y - text.top_y}
          fontSize={fragment.size - (fragment.sizeOffset || 0)}
          fontFamily={"Comic Neue"}
          text={fragment.displayText || "..."}
          fill={`black`}
          strokeWidth={2}
          ref={this.fragmentRefs[this.fragmentRefs.length - 1]}
          stroke={text.border ? text.border : null}
          align="center"
          verticalAlign="middle"
        />
      );
    });
    return (
      <Layer
        x={0}
        y={0}
        key={id}
        draggable
        rotation={text.rotation}
        onDragEnd={(e) => {
          let offsetX = e.target.x() - text.top_x;
          let offsetY = e.target.y() - text.top_y;
          updateTextLayer(id, {
            ...text,
            top_x: text.top_x + e.target.x(),
            top_y: text.top_y + e.target.y(),
            bottom_x: text.top_x + text.bottom_x + offsetX,
            bottom_y: text.top_y + text.bottom_y + offsetY,
          });
          // Reset position of group
          e.target.x(0);
          e.target.y(0);
        }}
      >
        <Rect
          x={text.top_x}
          y={text.top_y}
          width={text.bottom_x - text.top_x}
          height={text.bottom_y - text.top_y}
          fill={selected ? "pink" : null}
          ref={ref}
          onTransformStart={(e) => {
            start = {
              height: e.currentTarget.attrs.height,
              width: e.currentTarget.attrs.width,
              scaleX: e.currentTarget.attrs.scaleX,
              scaleY: e.currentTarget.attrs.scaleY,
              textHeight: e.currentTarget.attrs.textHeight,
              textWidth: e.currentTarget.attrs.textWidth,
              x: e.currentTarget.attrs.x,
              y: e.currentTarget.attrs.y,
            } as any;
          }}
          onTransformEnd={(e) => {
            let nextWidth = Math.floor(
              (text.bottom_x - text.top_x) * e.currentTarget.attrs.scaleX
            );
            let nextHeight = Math.floor(
              (text.bottom_y - text.top_y) * e.currentTarget.attrs.scaleY
            );
            const absScale = e.currentTarget.getAbsoluteScale();
            e.currentTarget.x(start.x);
            e.currentTarget.y(start.y);
            e.currentTarget.scaleX(e.currentTarget.scaleX() / absScale.x);
            e.currentTarget.scaleY(e.currentTarget.scaleY() / absScale.y);
            updateTextLayer(id, {
              ...text,
              bottom_x: nextWidth + text.top_x,
              bottom_y: nextHeight + text.top_y,
            });
          }}
        />
        {fragments}
        {selected && <Handler selectedLayer={ref} />}
      </Layer>
    );
  }
}

const Handler: React.FC<{ selectedLayer: any }> = ({ selectedLayer }) => {
  const [node, setNode] = React.useState(null);
  React.useEffect(() => {
    if (node && selectedLayer && selectedLayer.current) {
      console.log("here!!");
      console.log(node);
      console.log(selectedLayer.current);
      node.attachTo(selectedLayer.current);
      selectedLayer.current.draw();
      node.forceUpdate();
      node.getLayer().batchDraw();
    } else if (node) {
      node.detach();
    }
  }, [node, selectedLayer]);

  let log = (e: any) => {
    console.log(e.currentTarget);
  };

  return <Transformer ref={(node) => setNode(node)} onClick={log} />;
};

export default CanvasTextLayer;
